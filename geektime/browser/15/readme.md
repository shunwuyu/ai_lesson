# 消息队列和事件循环：页面是怎么“活”起来的

-  代码的执行顺序
```
console.log(111);
setTimeout(() => {
  console.log(222);
}, 0);
const p = new Promise((resolve, reject) => {
  console.log(333);
  resolve()
})
p.then(() => {
  console.log(444);
})
console.log(555);
```
111 333 555 444 222

为什么呢？

- 下图表达了啥？  
![](https://static001.geekbang.org/resource/image/b6/fc/b61cab529fa31301bde290813b4587fc.png?wh=1142*494)

这张图展示了现代浏览器的多进程架构：以浏览器主进程为调度中心，负责页面管理、进程创建（新tab 新渲染进程）与安全控制（sandbox）；每个页面运行在独立的渲染进程中，配合 sandbox 隔离（孩子在沙坑里玩沙子，Sandbox 就像“围栏”， 网页代码只能在围栏里玩，不能随便碰电脑的文件、系统和设备， 想做事必须先跟浏览器主进程申请，主进程审核后才放行，这样就算网页有问题，也伤不到系统。）；网络进程与 GPU 进程从主进程拆分，分别专注网络请求与图形加速，提升性能与稳定性；插件进程权限受限，进一步降低风险。整体体现了浏览器在安全性、稳定性与性能之间的工程化权衡，是大型系统解耦设计的典型案例。

蓝色：表示从浏览器主进程独立出来的专用进程（网络、GPU），强调其功能独立性与性能优化
白色：浏览器主进程，是核心调度中心，不带沙箱标识，代表权限最高、不受限；
红色边框/虚线：标注沙箱状态，说明该进程是否受安全隔离保护。

## 渲染进程的职责

核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。

GPU 进程：负责加速合成、动画、3D、视频等（辅助）
页面逻辑和渲染在渲染进程，GPU 只是被“调用来干活”。

- 主线程忙不忙？
  非常繁忙。 既要处理 DOM，又要计算样式，还要处理布局，同时还需要处理 JavaScript 任务以及各种输入事件。
  要让这么多不同类型的任务在主线程中有条不紊地执行，这就需要一个系统来统筹调度这些任务，这个统筹调度系统就是我们今天要讲的消息队列和事件循环系统。

## 使用单线程（JS）处理安排好的任务

比如有如下一系列的任务

任务 1：1+2任务 
2：20/5任务 
3：7*8任务 
4：打印出任务 1、任务 2、任务 3 的运算结果

```
function mainThread() {
    const num1 = 1 + 2;      // 任务1
    const num2 = 20 / 5;     // 任务2
    const num3 = 7 * 8;      // 任务3
    console.log(`最终计算的值为: ${num1}, ${num2}, ${num3}`); // 任务4
}

// 调用函数（可选）
mainThread();
```
![](https://static001.geekbang.org/resource/image/72/bc/72726678ac6604116c1d5dad160780bc.png?wh=1142*488)

我们把所有任务代码按照顺序写进主线程里，等线程执行时，这些任务会按照顺序在线程中依次被执行；等所有任务执行完成之后，线程会自动退出。

## 线程运行过程中处理新任务
不是所有的任务都是在执行之前统一安排好的，大部分情况下，新的任务是在线程运行过程中产生的。
线程运行过程中，能接收并执行新的任务，就需要采用事件循环机制。

比如事件， 定时器， api 请求到达....
```
//GetInput
//等待用户从键盘输入一个数字，并返回该输入的数字
function getInput() {
    const input = prompt("请输入一个数:");
    // 将字符串转为数字，若无效则返回 NaN
    return Number(input);
}

function mainThread() {
    while (true) {
        const firstNum = getInput();
        const secondNum = getInput();

        // 如果用户点击取消或输入非数字，退出循环
        if (isNaN(firstNum) || isNaN(secondNum)) {
            alert("输入无效，程序结束。");
            break;
        }

        const resultNum = firstNum + secondNum;
        alert(`最终计算的值为: ${resultNum}`);

        // 询问是否继续
        if (!confirm("是否继续计算？")) {
            break;
        }
    }
}

// 启动主逻辑
mainThread();
```
分析代码

- 引入了循环机制，具体实现方式是在线程语句最后添加了一个 while 循环语句，线程会一直循环执行。

- 引入了事件，可以在线程运行过程中，等待用户输入的数字，等待过程中线程处于暂停状态，一旦接收到用户输入的信息，那么线程会被激活，然后执行相加运算，最后输出结果。

![](https://static001.geekbang.org/resource/image/9e/e3/9e0f595324fbd5b7cd1c1ae1140f7de3.png?wh=1142*673)

- 处理其他线程发送过来的任务

所有的任务都是来自于线程内部的，如果另外一个线程想让主线程执行一个任务，利用**第二版**的线程模型是无法做到的。

![](https://static001.geekbang.org/resource/image/2e/05/2eb6a8ecb7cb528da4663573d74eb305.png?wh=1142*661)

渲染主线程会频繁接收到来自于 IO 线程的一些任务，接收到这些任务之后，渲染进程就需要着手处理，比如接收到资源加载完成的消息后，渲染进程就要着手进行 DOM 解析了；接收到鼠标点击的消息后，渲染主线程就要开始执行相应的 JavaScript 脚本来处理该点击事件。

如何设计好一个线程模型，能让其能够接收其他线程发送的消息呢？

- 一个通用模式是使用消息队列

![](https://static001.geekbang.org/resource/image/6d/5e/6d141ec0925590d83d97a37cce8e6f5e.png?wh=1142*316)

消息队列是一种数据结构，可以存放要执行的任务。它符合队列“先进先出”的特点，也就是说要添加任务的话，添加到队列的尾部；要取出任务的话，从队列头部去取。
银行排队叫号系统。
![](https://static001.geekbang.org/resource/image/2a/ab/2ac6bc0361cb4690c5cc83d8abad22ab.png?wh=1142*692)

- 添加一个消息队列；
```
class TaskQueue {
    constructor() {
        this.queue = []; // 使用数组存储任务
    }

    // 添加任务到队列尾部
    pushTask(task) {
        this.queue.push(task);
    }

    // 从队列头部取出一个任务（若队列为空，可返回 undefined）
    takeTask() {
        return this.queue.shift(); // shift() 移除并返回第一个元素
    }

    // 可选：查看队列是否为空
    isEmpty() {
        return this.queue.length === 0;
    }
}
```
- IO线程中产生的新任务添加进消息队列尾部；
```
task_queue；
ProcessTask();
funciton mainThread(){
  while(true){
    task = task_queue.takeTask();
    ProcessTask(task);
  }
}
```
所以如果有其他线程想要发送任务让主线程去执行，只需要将任务添加到该消息队列中就可以了，

- 渲染染主线程会循环地从消息队列头部中读取任务，执行任务。

主线程执行的任务都全部从消息队列中获取。所以如果有其他线程想要发送任务让主线程去执行，只需要将任务添加到该消息队列中就可以了


## 其他进程发送过来的任务

消息队列，我们实现了线程之间的消息通信
在 Chrome 中，跨进程之间的任务也是频繁发生的，那么如何处理其他进程发送过来的任务？

![](https://static001.geekbang.org/resource/image/e2/c6/e2582e980632fd2df5043f81a11461c6.png?wh=1142*834)

渲染进程专门有一个 IO 线程用来接收其他进程传进来的消息，接收到消息之后，会将这些消息组装成任务发送给渲染主线程，后续的步骤就和前面讲解的“处理其他线程发送的任务”一样了，这里就不再重复了。

## 消息队列中的任务类型
如输入事件（鼠标滚动、点击、移动）、微任务、文件读写、WebSocket、JavaScript 定时器等等。
消息队列中还包含了很多与页面相关的事件，如 JavaScript 执行、解析 DOM、样式计算、布局计算、CSS 动画等。

所以在编写 Web 应用时，你还需要衡量这些事件所占用的时长，并想办法解决单个任务占用主线程过久的问题,页面卡顿。

## 使用单线程的缺点（JS 单线程）
页面线程所有执行的任务都来自于消息队列。消息队列是“先进先出”的属性，也就是说放入队列中的任务，需要等待前面的任务被执行完，才会被执行。

- 如何处理高优先级的任务。

  - DOM 节点的变化
    节点的插入、修改、删除等动态变化
    一个通用的设计的是，利用 JavaScript 设计一套监听接口，当变化发生时，渲染引擎同步调用这些接口，这是一个典型的观察者模式。

    这个模式有个问题，因为 DOM 变化非常频繁，如果每次发生变化的时候，都直接调用相应的 JavaScript 接口，那么这个当前的任务执行时间会被拉长，从而导致执行效率的下降。

    DOM 变化做成异步的消息事件，添加到消息队列的尾部，那么又会影响到监控的实时性，因为在添加到消息队列的过程中，可能前面就有很多任务在排队了。

    如果 DOM 发生变化，采用同步通知的方式，会影响当前任务的执行效率；如果采用异步方式，又会影响到监控的实时性。

    如何权衡效率和实时性呢？

    **微任务**就应用而生了，下面我们来看看微任务是如何权衡效率和实时性的。

    我们把消息队列中的任务称为宏任务，每个宏任务中都包含了一个微任务队列，在执行宏任务的过程中，如果 DOM 有变化，那么就会将该变化添加到微任务列表中，这样就不会影响到宏任务的继续执行，因此也就解决了执行效率的问题。

    宏任务中的主要功能都直接完成之后，这时候，渲染引擎并不着急去执行下一个宏任务，而是执行当前宏任务中的微任务，因为 DOM 变化的事件都保存在这些微任务队列中，这样也就解决了实时性问题。

    是如何解决单个任务执行时长过久的问题。

    ![](https://static001.geekbang.org/resource/image/8d/cc/8de4b43fca99b180fdffe6a5af07b5cc.png?wh=1142*428)

    如果在执行动画过程中，其中有个 JavaScript 任务因执行时间过久，占用了动画单帧的时间，这样会给用户制造了卡顿的感觉，这当然是极不好的用户体验。针对这种情况，JavaScript 可以通过回调功能来规避这种问题，也就是让要执行的 JavaScript 任务滞后执行。至于浏览器是如何实现回调功能的，我们在后面的章节中再详细介绍。

- 解释开始的执行结果
```
我们来一步步分析这段 JavaScript 代码的执行顺序，结合 事件循环（Event Loop）、宏任务（MacroTask） 和 微任务（MicroTask） 的机制。

📌 前置知识简要回顾：
宏任务（MacroTask）：包括 script 整体代码、setTimeout、setInterval、I/O 等。
微任务（MicroTask）：包括 Promise.then/catch/finally 。 优先级
执行顺序规则：
执行当前宏任务；
执行所有当前可执行的微任务（清空微任务队列）；
渲染（如 UI 更新）；
取下一个宏任务，重复。
注意：整个 <script> 代码块本身就是一个初始宏任务。

🔍 逐行分析代码执行：
js
编辑
console.log(111);
✅ 同步执行 → 输出：111

js
编辑
setTimeout(() => {
  console.log(222);
}, 0);
🕒 setTimeout 是宏任务，其回调被放入宏任务队列，不会立即执行，要等当前宏任务和所有微任务执行完后才处理。

js
编辑
const p = new Promise((resolve, reject) => {
  console.log(333);
  resolve()
})
✅ 构造 Promise 时，executor 函数是同步执行的 → 输出：333

然后调用 resolve()，将 p 的状态变为 fulfilled。

js
编辑
p.then(() => {
  console.log(444);
})
📎 .then() 注册了一个微任务，该回调被加入微任务队列，不会立刻执行，但会在当前宏任务结束后、下一个宏任务开始前执行。

js
编辑
console.log(555);
✅ 同步执行 → 输出：555

✅ 当前宏任务（整个 script）执行完毕！
此时已输出：

text
编辑
111
333
555
接下来，清空微任务队列：

执行 p.then(...) → 输出：444
微任务队列清空。

🔄 进入下一轮事件循环：
从宏任务队列中取出最早的任务 —— setTimeout 的回调：

执行 console.log(222) → 输出：222
🎯 最终输出顺序：
text
编辑
111
333
555
444
222
🧠 总结关键点：
类型	内容	执行时机
同步代码	console.log(111/333/555)	立即执行（在初始宏任务中）
微任务	Promise.then	当前宏任务结束后立即执行
宏任务	setTimeout	下一轮事件循环中执行
💡 微任务优先于宏任务，且每轮宏任务只执行一次，但会清空所有微任务。

这就是 Event Loop 的核心调度逻辑。
```