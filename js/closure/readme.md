https://juejin.cn/post/7438153111877828645#heading-4

1. 变量提升怎么来的？ Hoisting
  1.js  
  画图
  变量或函数在执行上下文创建阶段，会被提升到函数作用域顶部。
  代码执行之前
  变量申明的提升， 函数值也会提升。 JavaScript引擎可以确保所有函数在需要时都是可用的
  1.jpg 改成有值
  执行 2.jpg 

2. let/const 没有变量提升？
  词法环境

3. 为什么要这么设计呢？
  变量提升不是什么好事。 let const 避免 放词法作用域

- v8 引擎代码执行 由调用栈 来执行
  - 代码执行顺序
  - 作用域链的引用关系
  - 释放内存  垃圾回收  出栈
  2.png   执行 给值

  fn 入栈

- 3.js
  函数的提升更优先  具有更高的优先级 调换两个的顺序
  ```
  var a = 2   // 可以放到下面
  function a() { }
  ```

  - 注掉 函数 传参的赋值 
    ```
    console.log(a) // 3  立即执行上下文  函数 形参 会负值
    var a = 2   // 可以放到下面
    //function a() { }
    
    var b = a
    console.log(a)
    ```

  - 多次声明会被忽略
    var a = 2  形参声明了 

  - 动态语言  var  a= 2 让函数变 2 

  - 调用栈
    v8 引擎用来管理函数之间的调用关系的一种数据结构
    1.编译总是发生在执行前一刻

    2.全局和函数体的编译会生成执行上下文，存入调用栈

    3.当一个函数执行完毕后，他的执行上下文就会被销毁

  编译的过程
    1. 创建执行上下文对象
    2. 找形参、变量、函数声明，将形参和声明的变量名作为key，值为undefined 
    3. 统一形参和实参的值 （全局没有，函数才有）
    4. 找函数声明，将函数名作为key，值为函数体 优先级更高
    5. 将执行上下文对象压入执行栈中

- 块级作用域
  ![](https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0b6f98cbaa564acd9c5776504271ab1a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Im-6ZuF5rOV5ouJ5ouJ:q75.awebp?rk3s=f64ab15b&x-expires=1732450588&x-signature=ytr2iqhZ5a88sKdqkW%2FfB%2BD2AoE%3D)

  - 为什么块级变量 出块不能访问？   出栈了 

## 作用域链

  6.js  为什么？

  词法作用域（lexical scope）是指在编程语言中，函数定义在了哪个域中（不是函数在哪里调用），这个域就叫该函数的词法作用域

  每一个执行上下文中都存在一个outer，这个outer就是指向的这个执行上下文的词法作用域，如果在执行上下文中找不到想要的变量，执行上下文就会去它outer指向的执行上下文中去找想要的变量。v8在查找变量的过程中，顺着执行上下文中的outer指向查清一整根链，这种链状关系就叫作用域链 查找变量的路径

  是的，词法作用域（Lexical Scoping）是在函数声明时确定的

## 闭包 
  7.js
    - 销毁foo
    - bar 返回 

    outer指向的地方也就是foo执行上下文中去找，但是你有没有发现因为函数foo已经执行完了所以foo执行上下文已经被销毁掉了，那bar说：'foo你带我走吧，你走了我可怎么活。"，不用担心foo还是留了一手的，虽然它被销毁了，但是它被需要的那部分变量还是会被保存到内存中，这就是闭包（closure）
    
    词法作用域的规则 和 函数调用完毕它的执行上下文一定会被销毁这一规则冲突

    根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量（outer）。当通过调用一个外部函数返回的一个内部函数时，即使外部函数调用完了（调用完会自动销毁），但是内部函数引用了外部函数中的变量，那么这些变量依然需要保存在内存中（注意是只保存需要的变量），我们把这些变量的集合称为 闭包


