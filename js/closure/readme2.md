1. 变量提升怎么来的？ Hoisting
  1.js  
  画图
  变量或函数在执行上下文创建阶段，会被提升到函数作用域顶部。
  代码执行之前
  变量申明的提升， 函数值也会提升。 JavaScript引擎可以确保所有函数在需要时都是可用的
  1.jpg 改成有值
  执行 2.jpg 

2. let/const 没有变量提升？2.js
  词法环境   DTD

3. 为什么要这么设计呢？
  变量提升不是什么好事。 let const 避免 放词法作用域

- 3.js
  函数的提升更优先  具有更高的优先级 调换两个的顺序
  ```  
  var a = 2   // 可以放到下面
  function a() { }
  ```

- 讲下执行过程 4.js
  代码经过v8引擎读取后，进行编译，编译将全局执行上下文放入调用栈中，并找到声明函数varTest，全局执行上下文编译过程结束。

  到全局执行上下文执行环节，执行函数varTest，又会产生varTest执行上下文，并将其放入调用栈中。

  对varTest执行上下文进行编译时，将 x = undefined 放入变量环境，注意if(){var x = 2}中使用 var 声明的变量是在函数作用域中，因此这时又有一个 x = undefined 会忽略 申明，varTest执行上下文编译过程结束。

  到varTest执行上下文执行环节时，先将 1 赋值给x ，随后再将 2 赋值给 x 输出 x 此时 x = 2 ，然后再输出x，即这段代码会输出两个 2 。

-  改成1会怎么样？
  ![](https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/639527bbd29543689ef67ea9c8c863ff~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Im-6ZuF5rOV5ouJ5ouJ:q75.awebp?rk3s=f64ab15b&x-expires=1733055420&x-signature=hut64kVSlcMzXA7gnhNnEGW%2Fc%2FM%3D)


-  再来做一个练习
  ![](https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8b315b1f3cc2449e8352a987f6ccdcec~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Im-6ZuF5rOV5ouJ5ouJ:q75.awebp?rk3s=f64ab15b&x-expires=1733055420&x-signature=HNyN2xBJhv78x1s31ssuPYEC0PY%3D)

  按照老办法先编译再执行，先把用 var 声明的变量 a 变量 c 都放进变量环境，然后用 let 声明的 b 放进词法环境 ，词法环境维护了一个新的栈，此时 b 先进栈，然后进入花括号，我们看到了 let ，let 与{ }会形成块级作用域，这个块级作用域又在词法环境中形成了一个块级上下文，存放用 let 声明的变量
b 变量 d 后编译结束,进入执行阶段依次赋完值后就是上图的样子。

  随后我们遇见了第一个console.log他在块级作用域中,，它要输出a，它要找a，它一定是先从词法环境中去找，并且从词法环境中维护的栈顶开始往下找。如果没找到就去变量环境中找，一路找到了变量环境中的a = 1，第二个console.log一下就在块级上下文中找到了即b = 3 ，运行出了{ }，即这个块级上下文执行完就销毁了


  此时第三个输出找的时候是这个样子，此时b = 2，第四个输出找变量c ，先找词法环境，词法环境中没有，就去找变量环境找到了c = 4 ，第五个输出找的是变量d ，而此时变量 d 只有在块级上下文中才有，但是这个块级作用域已经被销毁了，则这个 d 找不到任何值，程序就会报错。


- 作用域链 6.js

  - 词法作用域
    函数定义在了哪个域中（不是函数在哪里调用），这个域就叫该函数的词法作用域

    看图

    v8在查找变量的过程中，顺着执行上下文中的outer指向查清一整根链，这种链状关系就叫作用域链

- 闭包
  虽然它被销毁了，但是它被需要的那部分变量还是会被保存到内存中，这就是闭包（closure）
  为什么会有闭包这个概念：词法作用域的规则 和 函数调用完毕它的执行上下文一定会被销毁这一规则冲突
2.闭包的概念：在js中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量（outer）。当通过调用一个外部函数返回的一个内部函数时，即使外部函数调用完了（调用完会自动销毁），但是内部函数引用了外部函数中的变量，那么这些变量依然需要保存在内存中（注意是只保存需要的变量），我们把这些变量的集合称为 闭包
