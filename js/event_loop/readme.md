[source](https://juejin.cn/post/6844903919789801486?searchId=202507070910195C11986038AB504A37D8)

- 怎么理解JS是单线程的？
同一时间只能执行一个任务。



- 进程、线程
    CPU 承担了所有的计算任务

    进程

    假定工厂的电力有限，一次只能供给一个车间使用。 也就是说，一个车间开工的时候，其他车间都必须停工。 背后的含义就是，单个CPU一次只能运行一个任务。

    进程就好比工厂的车间，它代表CPU所能处理的单个任务。 进程之间相互独立，任一时刻，CPU总是运行一个进程，其他进程处于非运行状态。 CPU使用时间片轮转进度算法来实现同时运行多个进程。

    进程是分配资源的最小单元 （电力）

    线程

    线程就好比车间里的工人，一个进程可以包括多个线程，多个线程共享进程资源。


    进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）
    线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）
    不同进程之间也可以通信，不过代价较大
    单线程与多线程，都是指在一个进程内的单和多

- 浏览器是多进程
    图
    上图是 Google Chrome 的任务管理器界面，显示了各个子进程的内存占用、CPU 使用率和进程 ID。包括浏览器主进程、标签页、GPU 渲染进程和网络服务，每个功能模块分别独立运行，提升浏览器稳定性和性能。    

    实用进程是网络服务进程 
    每一个Tab页，就是一个独立的进程

    - 主进程
        - 协调控制其他子进程（创建、销毁）
        - 浏览器界面显示，用户交互，前进、后退、收藏
        - 将渲染进程得到的内存中的Bitmap，绘制到用户界面上
        - 处理不可见操作，网络请求，文件访问等
    - GPU进程
        - 用于3D绘制等
    - 渲染进程，就是我们说的浏览器内核
        - 负责页面渲染，脚本执行，事件处理等
            
            解析 HTML、CSS
            构建 DOM 树、渲染布局（Layout） Blink 是一个开源的布局和渲染引擎，负责解析 HTML 和 CSS 并将它们转换为可视化的网页。 处理包括 DOM 树构建、CSSOM 树构建、布局（Layout）、绘制（Paint）以及合成（Compositing）等任务。
            执行 JavaScript  V8 JavaScript 引擎
            处理用户交互（点击、滚动等）
            合成页面最终显示内容
        - 每个tab页一个渲染进程

- 渲染进程
    对于渲染进程来说，它当然也是多线程的了
    - GUI渲染线程
        负责渲染页面，布局和绘制
        页面需要重绘和回流时，该线程就会执行
        与js引擎线程互斥，防止渲染结果不可预期
    - JS引擎线程
        负责处理解析和执行javascript脚本程序
        只有一个JS引擎线程（单线程）
        与GUI渲染线程互斥，防止渲染结果不可预期
    - 事件触发线程
        用来控制事件循环（鼠标点击、setTimeout、ajax等）
        当事件满足触发条件时，将事件放入到JS引擎所在的执行队列中
    - 定时触发器线程
        setInterval与setTimeout所在的线程
        定时任务并不是由JS引擎计时的，是由定时触发线程来计时的
        计时完毕后，通知事件触发线程
    - 异步http请求线程
        浏览器有一个单独的线程用于处理AJAX请求
        当请求完成时，若有回调函数，通知事件触发线程

- 为什么要设计成单线程
    - 简化开发
    - 浏览器环境需求
    JavaScript 最初是为浏览器设计的脚本语言，主要用于操作 DOM 和响应用户交互。
    如果 JS 是多线程的，多个线程同时修改 DOM 会导致复杂的并发问题。
    - 事件驱动模型
    那么耗时性任务怎么办？
    JavaScript 采用事件循环（Event Loop）机制来处理异步操作（如定时器、网络请求、用户事件等），这种模型可以在不使用多线程的情况下实现高效的非阻塞 I/O 操作。
    I/O 指输入/输出操作，如读取文件、网络请求，是程序与外部设备的数据交互过程。   

- 为什么 GUI 渲染线程与 JS 引擎线程互斥
    这是由于 JS 是可以操作 DOM 的，如果同时修改元素属性并同时渲染界面(即 JS线程和UI线程同时运行)， 那么渲染线程前后获得的元素就可能不一致了。
    当JS引擎线程执行时GUI渲染线程会被挂起，GUI更新则会被保存在一个队列中等待JS引擎线程空闲时立即被执行。

## 从 Event Loop 看 JS 的运行机制
- JS 分为同步任务和异步任务
- 同步任务都在JS引擎线程上执行，形成一个执行栈
- 事件触发线程管理一个任务队列，异步任务触发条件达成，将回调事件放到任务队列中
- 行栈中所有同步任务执行完毕，此时JS引擎线程空闲，系统会读取任务队列，将可运行的异步任务回调事件添加到执行栈中，开始执行
看图：
左边是执行栈（同步代码先执行），异步任务（比如定时器、接口请求）会交给浏览器的“后台线程”处理，处理完后放到右边的“事件队列”。只有当执行栈清空了，Event Loop 才会一个个从事件队列中取出回调塞进执行栈执行。这就解释了为什么异步代码要等同步执行完才触发。

在前端开发中我们会通过setTimeout/setInterval来指定定时任务，会通过XHR/fetch发送网络请求，
接下来简述一下setTimeout/setInterval和XHR/fetch到底做了什么事
我们知道，不管是setTimeout/setInterval和XHR/fetch代码，在这些代码执行时，
本身是同步任务，而其中的回调函数才是异步任务。
当代码执行到setTimeout/setInterval时，实际上是JS引擎线程通知定时触发器线程，间隔一个时间后，会触发一个回调事件，
而定时触发器线程在接收到这个消息后，会在等待的时间后，将回调事件放入到由事件触发线程所管理的事件队列中。
当代码执行到XHR/fetch时，实际上是JS引擎线程通知异步http请求线程，发送一个网络请求，并制定请求完成后的回调事件，
而异步http请求线程在接收到这个消息后，会在请求成功后，将回调事件放入到由事件触发线程所管理的事件队列中。
当我们的同步任务执行完，JS引擎线程会询问事件触发线程，在事件队列中是否有待执行的回调函数，如果有就会加入到执行栈中交给JS引擎线程执行

这张图说明了异步任务是如何被浏览器调度的。同步代码（如 ajax、setTimeout）先被执行，但它们的具体处理会交给浏览器底层线程（比如：网络线程、定时器线程）。一旦处理完成，它们的回调函数就被放到右侧“任务队列”中。只有当主线程（执行栈）空了，事件循环（Event Loop）才会把这些回调取出来执行。这解释了为什么异步结果总是“后执行”。


- 什么是EventLoop
    Event Loop 是 JavaScript 中实现异步编程的机制，负责协调执行栈、任务队列与微任务队列，确保非阻塞运行。主线程执行同步代码后，轮询任务队列，将回调加入执行栈，逐步完成异步操作。


## 宏任务
我们可以将每次执行栈执行的代码当做是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）， 每一个宏任务会从头到尾执行完毕，不会执行其他。

我们前文提到过JS引擎线程和GUI渲染线程是互斥的关系，浏览器为了能够使宏任务和DOM任务有序的进行，会在一个宏任务执行结果后，在下一个宏任务执行前，GUI渲染线程开始工作，对页面进行渲染。
页面渲染不属于微任务或宏任务，它是在一个宏任务执行完毕、执行下一个宏任务之前，浏览器空隙时间自动插入的一步操作。

执行一个宏任务（JS逻辑）
→ 清空所有微任务
→ 📌【页面渲染机会】
→ 执行下一个宏任务

// 宏任务-->渲染-->宏任务-->渲染-->渲染．．．

主代码块，setTimeout，setInterval等，都属于宏任务


document.body.style = 'background:black';
document.body.style = 'background:red';
document.body.style = 'background:blue';
document.body.style = 'background:grey';


- setTimeout
它是由浏览器的 单独事件触发线程（也称为定时器线程） 管理的, 属于渲染进程。
- DOM event 
没有单独的线程， 浏览器的主线程（JS 引擎线程）**监听和处理
与 setTimeout 不同，DOM 事件的触发和回调执行都在主线程中完成。

特性	setTimeout	DOM 事件
触发机制	浏览器定时器线程	主线程监听用户行为或页面变化
回调放入队列	时间到后放入宏任务队列	事件触发后放入宏任务队列
执行线程	最终在 JS 主线程执行	始终在 JS 主线程执行

- XMLHttpRequest/fetch
由浏览器的 网络线程（Network Thread） 处理，不占用 JS 主线程。
请求完成后，回调函数（如 onreadystatechange）会被放入宏任务队列，并在 JS 主线程空闲时执行。

- fetch
同样由浏览器的 网络线程或进程 执行（更现代、更底层的网络栈）。
：使用 Promise，其 .then() 和 .catch() 回调属于微任务，在主线程执行，但可以配合 await 在异步函数中使用。
相比 XHR，fetch 更现代化，

宏任务队列和微任务队列都是在 JavaScript 主线程（即渲染进程中的 JS 引擎线程） 中管理和执行的

- 渲染进程的所有子线程

线程名称	用途描述
主线程（Main Thread）	运行 JavaScript、管理 DOM 树、计算样式、布局及绘制等核心操作。
工作线程（Worker Threads）	用于 Web Workers，允许在后台执行脚本而不影响页面性能。
栅格化线程（Raster Thread）	将绘图命令转换为像素，处理图像解码与重新采样。
合成器线程（Compositor Thread）	分割页面为多个层，并决定何时更新这些层以响应用户输入或动画。
计时器线程（Timer Thread）	管理 setTimeout 和 setInterval 的定时任务，确保回调能按时放入任务队列。
网络线程（Network Thread）	负责处理 HTTP 请求、响应以及其他网络活动，如 XHR 和 fetch 请求。
文件线程（File Thread）	处理本地文件系统访问相关的操作，比如读取或写入 IndexedDB 数据库。
音频线程（Audio Thread）	专门用于处理音频播放，确保音频流的连续性和低延迟。
