# 一句代码了解js的工作原理
- 1.js
  var a = 1;
  储存、访问和修改变量的值的能力将**状态**带给了程序
  a++  计数器 **状态**让程序变得有趣

- 阿娟
  高中， 一栋楼前， 那个位置。
  她爸爸， 带着大狼狗，接送她， 情窦初开就夭折了
  毕业 2年， 后鼓起勇气， 一层层，一间间房间查找， 突然有个男人的声音， 阿娟啊， 阿娟已经跟包租公在一起了。

- 变量属于作用域， 查找变量的规则 
  变量住在哪里？换句话说，它们储存在哪里？最重要的是，程序需要时如何找到它们？

- var a = 2;
  - 引擎 v8  负责整个JS的编译和执行
  - 编译器  引擎的好朋友之一，负责语法分析及代码生成等脏活累活
  - 作用域 引擎的另一位好朋友，负责收集并维护由所有声明的标识符（变量）组成的一系列查
询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。

- 在看
  - var a = 2; // 一句变量声明
  - 引擎却是如下理解
    - 编译器  分词 理解
      - var a
        - 编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的
集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作
用域的集合中声明一个新的变量，并命名为 a。
      ```js
      function foo() {
        var a = 1; // 编译器在当前作用域中声明一个新变量 a

        var a = 2; // 编译器发现当前作用域已存在名为 a 的变量，所以忽略该声明

        console.log(a); // 输出 2，因为第二个声明被忽略了
      }

      foo();
      ```
        - 接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理 a = 2 这个赋值
操作。引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫作 a 的
变量。

    如果引擎最终找到了 a 变量，就会将 2 赋值给它。否则引擎就会举手示意并抛出一个异
常！

  变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如
果之前没有声明过） ，然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对
它赋值。

  - 编译 和 执行 是两个阶段
    查找过程 ， 作用域，  存在那个作用域里，  到那个作用域里去找

- LHS RHS
  当变量出现在赋值操作的左侧时进行LHS 查询，出现在右侧时进行RHS 查询

  LHS 引用指的是赋值操作的目标是谁。 当变量出现在赋值操作的左侧时，我们想要找到的是这个变量的容器，以便对其赋值。
  RHS 引用指的是赋值操作的源头是谁。 当变量出现在赋值操作的右侧时，我们想要的是获取这个变量的值。

  a = 2; LHS a 是 LHS 引用，因为我们想要找到 a 的容器并将值 2 赋给它。
  console.log(a) RHS 我们想要获取 a 的值并将其传递给 console.log() 函数。

  - 习题
  ```js
  function foo(a) { // LHS 隐式
    console.log( a ); // 2 RHS 
  }
  // RHS 
  //foo 进行 RHS 引用，意味着“去找到 foo 的值，并把它给我”。并且(..) 意味着 foo 的值需要被执行，因此它最好真的是一个函数类型的值
  foo( 2 );
  ```

  - 对话很重要



  - 习题二
  ```
  function foo(a) { // LHS 隐式 变量分配
    var b = a;   // b  LHS 隐式 变量分配    // a  RHS  查找 a 的值
    return a + b; // RHS  2次
  }
  // LHS  c 在左侧 找容器
  var c = foo( 2 ); // 查找foo的值， RHS 
  ```

- 作用域嵌套
  作用域是根据名称查找变量的一套规则， 俄罗斯套娃一样
  当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套
  ```js
  function foo(a) {
    console.log( a + b ); // RHS 引用 
  }
  var b = 2; // 全局变量
  foo( 2 ); // 4
  ```

  在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，
或抵达最外层的作用域（也就是全局作用域）为止。

  对话

  遍历嵌套作用域链的规则很简单：引擎从当前的执行作用域开始查找变量，如果找不到，
就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都
会停止。

- 异常

  ```js
  function foo(a) {
    console.log( a + b );
    b = a;
  }
  foo( 2 );
  ```
  为什么区分LHS 和RHS 是一件重要的事情？
  因为在变量还没有声明（在任何作用域中都无法找到该变量）的情况下，这两种查询的行
为是不一样的。
  ReferenceError 同作用域判别失败相关，而 TypeError 则代表作用域判别成功了，但是对
结果的操作是非法或不合理的。



