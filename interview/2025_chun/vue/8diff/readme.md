![](https://juejin.cn/post/7114177684434845727?searchId=20250313090120C5B0FE94A378505577B3)

- 介绍下diff 算法

Vue 和 React 都是基于 vdom 的前端框架
组件渲染会返回 vdom，渲染器再把 vdom 通过增删改的 api 同步到 dom。

当再次渲染时，会产生新的 vdom，渲染器会对比两棵 vdom 树，对有差异的部分通过增删改的 api 更新到 dom。

这里对比两棵 vdom 树，找到有差异的部分的算法，就叫做 diff 算法。

- 图中diff 算法的时间复杂度是多少？
  ![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f0312e46cfa4d978397c429ab4c191b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)
  O(n^3)
  因为每个节点都要去和另一棵树的全部节点对比一次，这就是 n 了，如果找到有变化的节点，执行插入、删除、修改也是 n 的复杂度。所有的节点都是这样，再乘以 n，所以是 O(n * n * n) 的复杂度。

  这样的复杂度对于前端框架来说是不可接受的，这意味着 1000 个节点，渲染一次就要处理 1000 * 1000 * 1000，一共 10 亿次。

- 怎么解决？
  只做**同层**的对比，type 变了就不再对比子节点。

  dom 节点做跨层级移动的情况还是比较少的

  这样只要遍历一遍，对比一下 type 就行了，是 O(n) 的复杂度，而且 type 变了就不再对比子节点，能省下一大片节点的遍历。

  另外，因为 vdom 中记录了关联的 dom 节点，执行 dom 的增删改也不需要遍历，是 O(1)的，整体的 diff 算法复杂度就是 O(n) 的复杂度。

  每个虚拟DOM节点通常会包含一个指向其对应的真实DOM节点的引用（如果存在）。

- 如![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5dbd325446ee4d219d6e8876219718c1~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?) diff 会怎么做？
  - 根节点：保持不变。
  - 第一个子节点：保持不变。
  - 第二个子节点：
    - 移除旧的<p>节点。
    - 插入新的<div>节点。
    - 新的<div>中的<span>节点的内容。

## 没解决的问题
### 根据type 
- 有 5 个，类型是 ABCDE，下次渲染出来的是 EABCD
  这时候逐一对比，发现 type 不一样，就会重新渲染这 5 个节点。
  而且根据 type 不同就不再对比子节点的原则，如果这些节点有子节点，也会重新渲染。
  dom 操作是比较慢的，这样虽然 diff 的算法复杂度是低了，重新渲染的性能也不高。

  diff 算法除了考虑本身的时间复杂度之外，还要考虑一个因素：**dom 操作的次数**。

- 上面例子 最简单的操作是？
  很明显只需要移动一下 E 就行了，根本不用创建新元素。
  key 假设渲染 ABCD 一组节点，再次渲染是 DCAB 这么说就可以了
  最好每个节点都是有唯一的标识。
  所以当渲染一组节点的时候，前端框架会让开发者指定 key，通过 key 来判断是不是有点节点只是发生了移动，从而直接复用。

  我们会把基于 key 的两组节点的 diff 算法叫做多节点 diff 算法，它是整个 vdom 的 diff 算法的一部分。


## 简单diff
ABCD 一组节点，再次渲染是 DCAB 这么说就可以了
多节点 diff 算法的目的是为了尽量复用节点，通过移动节点代替创建。

diff 算法的目的是根据 key 复用 dom 节点，通过移动节点而不是创建新节点来减少 dom 操作。
对于每个新的 vnode，在旧的 vnode 中根据 key 查找一下，如果没查找到，那就新增 dom 节点，如果查找到了，那就可以复用。
复用的话要不要移动要判断下下标，如果下标在 lastIndex 之后，就不需要移动，因为本来就在后面，反之就需要移动。
最后，把旧的 vnode 中在新 vnode 中没有的节点从 dom 树中删除。


先从旧的 vnode 数组中查找对应的节点，如果找到了就代表可以复用，接下来只要移动就好了。
如果没找到，那就执行插入，锚点是上一个节点的 nextSibling。

EABCD ABCDE  

何时要移动？ j < lastIndex  旧DOM 中的顺序比已
当新节点在旧列表中的索引小于lastIndex时，需要移动该节点以保持顺序。
lastIndex用于追踪已处理节点在旧列表中的最大索引，判断是否需移动新节点以维持顺序。

步骤1: 处理新VDOM的第一个节点'E'
  - 在oldChildren中寻找与'E'具有相同key的节点。
  - 找到了位于oldChildren[4]的'E'。
  - 调用patch更新'E'，然后检查是否需要移动。
  - 因为j(=4)大于lastIndex(=0)，不需要移动，并更新lastIndex = 4。
步骤2: 处理'A'
  - 在oldChildren中寻找与'A'具有相同key的节点。
  - 找到了位于oldChildren[0]的'A'。
  - 调用patch更新'A'，然后检查是否需要移动。
  - 因为j(=0)小于lastIndex(=4)，需要移动。
  - 'E'的下一个兄弟节点是'A'，所以将'A'插入到'E'之后的位置。
  在旧DOM中，E是最后一个节点，所以prevNode.el.nextSibling原本应为空。但在新DOM中调整顺序时，它用于确定A应插入到E之后的位置。
  1.html demo
  BCDEA
步骤3: 处理'B'
  - 在oldChildren中寻找与'B'具有相同key的节点。
  - 找到了位于oldChildren[1]的'B'。
  - 调用patch更新'B'，然后检查是否需要移动。
  - 因为j(=1)小于lastIndex(=4)，需要移动
  - 'A'的下一个兄弟节点是'B'，所以将'B'插入到'A'之后的位置。
  CDEAB
步骤4: 处理'C'
  - 在oldChildren中寻找与'C'具有相同key的节点。
  - 找到了位于oldChildren[2]的'C'。
  - 调用patch更新'C'，然后检查是否需要移动。
  - 因为j(=2)小于lastIndex(=4)，需要移动
  - 'B'的下一个兄弟节点是'C'，所以将'C'插入到'B'之后的位置。
  DEABC
步骤5: 处理'D'
  - 在oldChildren中寻找与'D'具有相同key的节点。
  - 找到了位于oldChildren[3]的'D'。
  - 调用patch更新'D'，然后检查是否需要移动。
  - 因为j(=3)小于lastIndex(=4)，需要移动
  - 'C'的下一个兄弟节点是'D'，所以将'D'插入到'C'之后的位置。
  EABCD

这个 diff 算法我们是从一端逐个处理的，叫做简单 diff 算法。
简单 diff 算法其实性能不是最好的 移动次数太多了
简单 diff 算法能够实现 dom 节点的复用
但有的时候会做一些没必要的移动

## 双端 diff

双端 diff 是头尾指针向中间移动的同时，对比头头、尾尾、头尾、尾头是否可以复用，如果可以的话就移动对应的 dom 节点。
如果头尾没找到可复用节点就遍历 vnode 数组来查找，然后移动对应下标的节点到头部。
最后还剩下旧的 vnode 就批量删除，剩下新的 vnode 就批量新增。

通过上述步骤，我们成功地将旧VDOM ABCDE 更新为新VDOM EABCD。这个过程中，我们首先找到了新列表中的第一个节点 'E' 并将其移动到了最前面，然后依次对后续的节点进行了比较和更新。最终实现了高效的DOM更新，同时尽量复用了现有的DOM元素，减少了不必要的DOM操作。