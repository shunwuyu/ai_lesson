数组有5项，如何过滤大于2的数 给出js解法
1.js
空间复杂度和时间复杂度
时间复杂度
O(n) —— 你得把数组中每个元素都看一遍，判断它是否大于 2。
（n 是数组长度）
空间复杂度
O(k) —— k 是大于 2 的元素数量（因为要新建一个结果数组保存它们）。
最坏情况下（所有元素都大于 2），就是 O(n)。

如何降低时间复杂度？
没办法再降。
因为你必须检查每个元素，无法跳过任何一个，所以最优也是 O(n)。

唯一能“加速”的，是在特殊场景下：
如果数组已经有序，你可以用二分查找（O(log n)）直接找到第一个大于 2 的位置，然后一次性切片剩下部分。

2.js

## 介绍二分法 空间复杂度是多少
二分法就是一种“折半查找”的思路，用来在有序数组里快速找目标值。每次取中间元素，比目标大就往左找，比目标小就往右找，不断缩小范围，直到找到或范围为空。时间复杂度是 O(log n)，非常高效。

二分法的空间复杂度是多少
O(1) —— 只需要常数个额外变量（如 left、right、mid 等），不随数组长度变化而变化。

## 分治
“分治”，分而治之。其思想就是将一个大问题分解为若干个子问题，针对子问题分别求解后，再将子问题的解整合为大问题的解。

利用分治思想解决问题，我们一般分三步走：

分解子问题
求解每个子问题
合并子问题的解，得出大问题的解

## 归并排序

归并排序是对分治思想的典型应用，它按照如下的思路对分治思想“三步走”的框架进行了填充：

分解子问题：将需要被排序的数组从中间分割为两半，然后再将分割出来的每个子数组各分割为两半，重复以上操作，直到单个子数组只有一个元素为止。
求解每个子问题：从粒度最小的子数组开始，两两合并、确保每次合并出来的数组都是有序的。（这里的“子问题”指的就是对每个子数组进行排序）。
合并子问题的解，得出大问题的解：当数组被合并至原有的规模时，就得到了一个完全排序的数组

[8, 7, 6, 5, 4, 3, 2, 1]
[8, 7, 6, 5,| 4, 3, 2, 1]
[8, 7,| 6, 5,| 4, 3,| 2, 1]
[8,| 7,| 6,| 5,| 4,| 3,| 2,| 1]
[7, 8,| 5, 6,| 3, 4,| 1, 2]
[5, 6, 7, 8,| 1, 2, 3, 4]  
[1, 2, 3, 4, 5, 6, 7, 8]  

通过上面的讲解，我们可以总结出归并排序中的两个主要动作：

分割
合并

这两个动作是紧密关联的，分割是将大数组反复分解为一个一个的原子项，合并是将原子项反复地组装回原有的大数组。整个过程符合两个特征：

重复（令人想到递归或迭代）
有去有回（令人想到回溯，进而明确递归这条路）

归并排序在实现上依托的就是递归思想。
除此之外，这里还涉及到另一个小小的知识点——两个有序数组的合并。

双指针法

3.js

时间复杂度

对于规模为 n 的数组来说，需要切分 log(n) 次，因此就有 log(n) 轮。