[source](https://juejin.cn/book/6844733800300150797/section/6844733800367259655)

“分治”，分而治之。其思想就是将一个大问题分解为若干个子问题，针对子问题分别求解后，再将子问题的解整合为大问题的解。

一个大问题分解为若干个子问题 -》 递归 函数自身调用自身 分治常借助递归实现

利用分治思想解决问题，我们一般分三步走：
- 分解子问题
- 求解每个子问题
- 合并子问题的解，得出大问题的解

- 归并排序
  归并排序是对分治思想的典型应用，

  分解子问题：将需要被排序的数组从中间分割为两半，然后再将分割出来的每个子数组各分割为两半，重复以上操作，直到单个子数组只有一个元素为止。
  求解每个子问题：从粒度最小的子数组开始，两两合并、确保每次合并出来的数组都是有序的。（这里的“子问题”指的就是对每个子数组进行排序）。
  合并子问题的解，得出大问题的解：当数组被合并至原有的规模时，就得到了一个完全排序的数组

- [8, 7, 6, 5, 4, 3, 2, 1]
  [8, 7, 6, 5,| 4, 3, 2, 1]
  [8, 7,| 6, 5,| 4, 3,| 2, 1]
  [8,| 7,| 6,| 5,| 4,| 3,| 2,| 1]
  [7, 8,| 5, 6,| 3, 4,| 1, 2]
  [5, 6, 7, 8,| 1, 2, 3, 4] 
  [1, 2, 3, 4, 5, 6, 7, 8]  

- 分割
- 合并

原子项反复地组装回原有的大数组。整个过程符合两个特征：

重复（令人想到递归或迭代）
有去有回（令人想到回溯，进而明确递归这条路）

因此，归并排序在实现上依托的就是递归思想。
除此之外，这里还涉及到另一个小小的知识点——两个有序数组的合并。合并有序数组是咱们在第 7 节讲过的一道真题，涉及到双指针法。此处强烈建议印象模糊的同学回头复习一下完整的解题思路。

归并排序的时间复杂度分析

基于数学计算的分析

我们假设规模为 n 的数组对应的排序的时间复杂度是一个关于 n 的函数 F(n)。那么它和自己的两个子数组之间就有如下关系：

- 对于规模为 n 的数组来说，需要切分 log(n) 次，因此就有 log(n) 轮。

O(nlog(n))

## 快速排序

选一个基准，把比它小的放左边，比它大的放右边，再对左右两边递归排序（分治思想）。

快速排序会将原始的数组筛选成较小和较大的两个子数组，然后递归地排序两个子数组。

首先要做的事情就选取一个基准值。基准值的选择有很多方式，这里我们选取数组中间的值：

[5, 1, 3, 6, 2, 0, 7]
 ↑       基准      ↑

 左右指针分别指向数组的两端。接下来我们要做的，就是先移动左指针，直到找到一个不小于基准值的值为止；然后再移动右指针，直到找到一个不大于基准值的值为止。
首先我们来看左指针，5比6小，故左指针右移一位：


- 最好时间复杂度：它对应的是这种情况——我们每次选择基准值，都刚好是当前子数组的中间数。这时，可以确保每一次分割都能将数组分为两半，进而只需要递归 log(n) 次。这时，快速排序的时间复杂度分析思路和归并排序相似，最后结果也是 O(nlog(n))。

- 最坏时间复杂度：每次划分取到的都是当前数组中的最大值/最小值。大家可以尝试把这种情况代入快排的思路中，你会发现此时快排已经退化为了冒泡排序，对应的时间复杂度是 O(n^2)。