## CDN 加速与缓存一致性
你们团队上线了一张用户头像图片，放在 CDN 上做加速。后来后端同学更新了头像文件，但前端刷新页面后，用户依旧看到的是旧头像。

CDN 通过将图片缓存到全球各地的边缘节点，使用户就近访问，减少网络延迟和服务器负载，从而加速图片加载。

- 这是什么原因？
- 作为前端，你能怎么解决？
原因：CDN 边缘节点有缓存，浏览器本地也有缓存（强缓存、协商缓存），所以会出现旧内容。
解决方法：
  给资源加上 版本号或 hash（比如 avatar.png?v=123 或 avatar.abc123.png）来避免缓存污染；
  服务端设置合理的 Cache-Control，对需要强一致的资源设置较短的 max-age，或者加上 no-cache；
  CDN 配置上可设置缓存刷新策略，比如手动/自动刷新。

## 前端请求为什么要做跨域，浏览器为什么要有同源策略
场景描述：
你在前端调用一个第三方接口，结果报了 CORS error。你去查资料发现是 “同源策略” 导致的。
浏览器为什么要有同源策略？
前端有哪些方式可以解决跨域？

理想回答要点：
同源策略限制网页只能访问同源（协议、域名、端口相同）的资源，防止恶意网站在你登录状态下，偷偷读取或操作其他网站（如银行、邮箱）的数据，避免敏感信息被窃取或执行非授权操作，是浏览器隔离风险的核心安全机制。

跨域解决方案：
  CORS：服务端配置 Access-Control-Allow-Origin；
  CORS 是服务端说了算的白名单机制。恶意网站没法让别人的服务器给它开权限，所以跨域偷数据行不通。
  你访问了恶意网站 evil.com，它想偷 bank.com 的数据。
  浏览器发出请求：GET bank.com/api/balance
  bank.com 服务器响应头中没有 Access-Control-Allow-Origin: evil.com
  浏览器发现：不允许 evil.com 跨域读取！
  → 拦截响应，前端 JS 拿不到数据
  所以，只有银行自己愿意（配置了 CORS），比如允许 partner.com，那合作网站才能读取。

- JSONP：利用 <script> 标签不受同源策略限制（只支持 GET）；

  

- 代理转发：前端本地开发时用 webpack/vite dev server 代理，线上用 Nginx 转发；
  前端 JS 请求: fetch('/api/user')
       ↓
  Vite 开发服务器（localhost:5173）拦截 /api 开头的请求
        ↓
  Vite 代理转发到: http://localhost:3000/api/user
        ↓
  后端返回数据
        ↓
  Vite 再把响应返回给前端
        ↓
  浏览器控制台打印数据 ✅

  浏览器看到的是：请求发给了同源的 localhost:5173
  实际数据是从 3000 来的，但浏览器不知道（因为是服务器端转发）
  所以不触发跨域限制
    正向代理  由客户端（前端开发环境）主动配置，代理前端发出的请求

  - nginx location /api/ {
      proxy_pass http://backend:3000/;
    }
    反向代理 生产级别
    客户端无感知，服务端在背后做转发

    反向代理（Reverse Proxy） 是指：

    客户端直接访问的是一个代理服务器（如 Nginx）
    代理服务器代表客户端去请求真正的后端服务
    客户端不知道背后的真实服务器是谁
    从客户端视角看：它只和 Nginx 通信

    你去餐厅点菜，服务员（Nginx）把单子传给厨房（后端），菜做好再由服务员给你。你没见过厨房。

- postMessage / iframe 通信：跨域页面之间传递数据。
  https://github.com/shunwuyu/ai_lesson/blob/ae19ba7c31dd893e70b59b77cd3dc4e87277f192/interview/2025_chun/js/cors/postmessage-demo/index.html

- websocket：全双工通信，服务器和客户端可以随时发送数据。
  https://github.com/shunwuyu/ai_lesson/blob/ae19ba7c31dd893e70b59b77cd3dc4e87277f192/interview/2025_chun/js/cors/websocket-demo/index.html

## HTTP/1.1、HTTP/2 和 HTTP/3 的区别与场景选择

- 场景描述：
假设你负责一个复杂的 Web 应用，需要加载几十个静态资源文件（JS、CSS、图片等），用户抱怨首屏加载很慢。

- 为什么在 HTTP/1.1 下加载会很慢？
队头阻塞（Head-of-line blocking）：同一个 TCP 连接里一个请求没结束，后面的都得等；
浏览器默认一个域名最多 6 个连接，遇到几十个资源请求时会排队。

- HTTP/2 改进：
  单个 TCP 连接支持 多路复用，并发传多个请求/响应；
  建立在「二进制分帧层」的基础上，而它的基本单位就是更小的「帧（Frame）」—— 二进制格式的数据块。
  每个请求/响应对应一个「流」（Stream）
  每个帧都带有一个 Stream ID，标识它属于哪个流
  不同流的帧可以交错混在一起发送，接收方根据 Stream ID 重新组装
  支持 Header 压缩，节省带宽；
  服务器推送（Server Push），可主动推资源给客户端。

- HTTP/3 改进：
  基于 QUIC/UDP，解决 TCP 层的队头阻塞，丢包时不会阻塞其他流；
  建立连接更快（0-RTT）。

  HTTP/2 虽能并发传输多个请求（多路复用），但底层仍依赖 TCP。若一个数据包丢失，TCP 会阻塞整个连接等待重传，导致所有并行流都被卡住——这就是“TCP 队头阻塞”。应用层的并发，被传输层的可靠性机制拖累。

  UDP（User Datagram Protocol）是一种无连接、不保证可靠传输但速度快的传输层协议，常用于实时音视频、在线游戏等对时延敏感的场景。

  QUIC 基于 UDP，自实现可靠传输，每个流独立重传，丢包不影响其他流；无需等待 TCP 重传，避免了传输层队头阻塞，实现真正并行。

  0-RTT 建立连接指客户端在 无需等待完整握手完成的情况下就能发送数据，从而显著降低首次通信延迟。

  客户端 (Client)                             服务端 (Server)
      | --------- SYN=1, seq=x -----------> |   （我要连你，可以吗？）
      | <---- SYN=1, ACK=1, seq=y, ack=x+1 |   （我收到了请求，我也同意连你）
      | --------- ACK=1, ack=y+1 ---------> |   （好的，确认没问题，开始吧！）


SYN 是同步标志位，用于发起连接请求，同步双方的初始序列号。
SYN = 1 表示该数据包是一个连接请求或连接接受报文，用于建立TCP连接。

ACK 是确认标志位，=1 表示该报文是一个确认报文，确认收到了对方发送的数据。

ack=x+1 是确认号，表示“我（服务端）已经收到了你（客户端）发送的序列号为 x 的 SYN 包，期待你下次发序列号为 x+1 的数据”。