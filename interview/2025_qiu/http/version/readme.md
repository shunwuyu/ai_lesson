# http 各个版本有哪些特性

考察的不只是背诵，而是能否层层递进、结合案例、突出关键考点

- HTTP/0.9 （了解即可）
    最早的版本，只支持 GET 请求，响应只有 HTML 文本，没有 header。
    只能传简单网页，连图片、CSS、JS 都不行。

- HTTP/1.0
    - 引入了 header，能传输多种类型数据（图片、视频）。
    - 每次请求都要重新建立 TCP 连接（无连接）。

    请求一个网页要下载很多资源，反复建立 TCP → 性能差。
    知道 “多请求多连接” 的缺点。

- HTTP/1.1（重点，常考）
    长连接：默认开启 Connection: keep-alive，一个 TCP 可处理多个请求。
        浏览器通过一个TCP连接连续请求页面、图片、脚本等多个资源，服务器处理完不立即断开，而是保持连接，后续请求无需重新建立连接，节省时间，提高加载速度。
    管道化（pipelining）：允许同时发多个请求，但响应必须按顺序返回（队头阻塞）。
        你用支持管道化的浏览器，依次发送“获取首页”“获取图片1”“获取图片2”三个请求，无需等待前一个响应。但服务器必须按顺序返回：先首页，再图片1，最后图片2。若首页响应慢，后续响应即使处理完也需排队，造成队头阻塞。
        
        管道化允许客户端连续并发发送多个请求，无需等待响应。但服务器必须按请求顺序依次返回响应，若前面的响应未完成，后面的即使就绪也需等待，导致队头阻塞。

        不知道数据包谁是谁的。 

    缓存控制：Cache-Control、ETag 等。 不用重复请求
        304 Not Modified
        强缓冲
        协商缓存



    分块传输编码（chunked transfer）。
        HTTP/1.1 分块传输编码（chunked transfer）是一种数据传输方式，用于服务器在不知道总数据大小的情况下，边生成内容边发送。

        它把响应体分成多个“块”（chunk），每块前面带上该块的大小（十六进制），最后用一个大小为0的块表示结束。这样，服务器无需预先知道全部内容长度，也能逐步发送数据，特别适合动态生成页面（如实时日志、大文件流）。


    面试常问“HTTP/1.1 为什么有性能瓶颈？” → 答：队头阻塞 + 并发连接数有限（Chrome 每域名 6 个）。
        - 资源合并
            将多个小 JS/CSS 文件合并，减少请求数。
            
        - 雪碧图（CSS Sprites）
            将多个小图标合并成一张大图，用 CSS 定位显示部分，减少图片请求数。
            background-position
            ![](https://img1.baidu.com/it/u=4208199278,229741321&fm=253&fmt=auto&app=138&f=PNG?w=1035&h=437)
        - Base64 内嵌
            将小图片转为 Base64 编码直接嵌入 HTML/CSS，避免额外请求（但会增大体积，适合极小资源）
        - 图标字体库（Icon Fonts）
            用字体文件替代多个图标图片，一次请求加载多个图标。
        - 使用多个域名（域分片，Domain Sharding）：将资源分布在不同子域名下（如 static1.example.com, static2.example.com），突破浏览器每域名连接数限制，实现更多并行请求。
            juejin 多域名图片
        - 开启长连接（Keep-Alive）：复用 TCP 连接，减少连接建立开销。
        - 启用压缩（Gzip）：减小传输体积，提升加载速度
        - 合理缓存：使用强缓存（Cache-Control）和协商缓存（ETag/Last-Modified），减少重复请求。

- HTTP/2（大厂高频考点 🚀）
    - 二进制分帧：效率比文本协议高。
        HTTP/2 用“多路复用”取代管道化，所有请求和响应都拆成小数据帧，通过同一个连接并发传输，每个帧带编号，客户端和服务端根据编号重组。这样，响应无需排队，谁先准备好谁就先发，彻底解决了队头阻塞问题。
    - 多路复用：一个 TCP 连接上并发多个请求响应，不再队头阻塞（同连接内）。
        管道化（pipelining）只是让多个请求可以连续发出，但响应仍按顺序返回，容易因一个慢请求卡住后续；多路复用（multiplexing）把数据拆成帧交错传输，请求和响应可并行独立，不会互相阻塞，彻底解决队头阻塞问题。

    - 头部压缩（HPACK）：减少重复 header 传输。
        它用静态和动态表记录常用头字段，重复头用索引代替，避免重复传输；新增头用霍夫曼编码压缩。大幅减少头部体积，节省带宽，提升传输效率。
    - 服务器推送（Server Push）：服务端可主动推送资源（现已被弃用）。
        首页 GET / 返回很快，但首屏还依赖 app.css、app.js、brand.woff2。为了减少首轮往返，网关/源站在返回 HTML 的同时 Push 这些关键静态资源。

    问到“HTTP/2 如何解决 1.1 的问题？” → 答：多路复用 + 头部压缩。
    

- HTTP/3（进阶，追问必考）
    - 基于 QUIC 协议（UDP），不是 TCP。
        HTTP/3 基于 QUIC 协议，改用 UDP 代替 TCP 作为传输层。QUIC 在 UDP 上实现可靠传输，并内置 TLS 1.3 和多路复用，避免 TCP 的队头阻塞和高连接延迟，提升连接速度和抗丢包能力，尤其适合弱网环境。
    - 内置 TLS 1.3，更安全。
    - 连接迁移：IP 变了也能保持连接（比如 Wi-Fi 切 4G）。
    - 彻底解决 TCP 队头阻塞问题。
    问“HTTP/3 为什么基于 UDP 而不是 TCP？” → 答：避免 TCP 队头阻塞，同时在应用层实现拥塞控制。