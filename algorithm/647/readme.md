[source](https://leetcode.cn/problems/palindromic-substrings/description/)

# 回文子串

- 回文字符串 是正着读和倒过来读一样的字符串。
- 子字符串 是字符串中的一个连续序列。

- "abc"
  a b c  3
- "aaa"
  a a a aa aa aaa  

- 暴力破解法
  两层for 循环遍历输入字符串的起始位置和结束位置，然后判断该子串是否为回文。
  时间复杂度：O(n^3)，其中 n 是字符串的长度。因为需要两层循环遍历起始位置和结束位置，以及判断每个子串是否为回文，时间复杂度为 O(n^2)，判断回文的时间复杂度为 O(n)。
  空间复杂度：O(1)。

- 为什么会用动态规划？
  因为每个子串是否为回文的状态可以由其内部子串的回文状态推导得出，即如果去掉两端字符后的子串是回文且两端字符相同，则该子串也是回文。
  通过构建一个二维表记录这些状态，能够避免重复计算，从而高效解决问题。这种方法利用了子问题重叠性质，优化了求解过程。

- 动规五部曲
  - dp 数组以及下标的含义
    dp[i][j] 表示字符串 s 在 [i, j] 区间的子串是否是一个回文串。 boolean 
  - 递推公式 s[i] s[j]是否相等
    如果 s[i] != s[j]，那么 dp[i][j] = false。
    如果 s[i] == s[j]，此时有如下三种情况
      - i == j，同一个字符例如 a，当然是回文串 单个字符
      - j - i == 1，例如 aa，也是回文串
      - j - i > 1，例如 cabac，此时 s[i] 与 s[j] 已经相同了，我们看 i 到 j 区间是不是回文串就看aba是不是回文就可以了，那么 aba 的区间就是 i + 1 与 j - 1 区间，这个区间是不是回文就看 dp[i + 1][j - 1] 决定的。

    ```js
    if (s[i] == s[j]) {
      if (j - i <= 1) { // 情况一 和 情况二
        result++;
        dp[i][j] = true;
      } else if (dp[i + 1][j - 1]) { // 情况三
        result++;
        dp[i][j] = true;
      }
    }
    ```

  - dp 数组初始化
  默认是false
  - 遍历顺序
  情况三 dp[i+1][j-1] 为true dp[i][j]为true 
  dp[i+1][j-1]在左下角 所以要从下到上 从左到右遍历 

  - 举例推导dp数组
  输入：s = "aaa"
  输出：6
  解释：6个回文子串: "a", "a", "a", "aa", "aa", "aaa"
  左边不存在
