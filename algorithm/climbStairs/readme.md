https://juejin.cn/book/6844733800300150797/section/6844733800367276039

- 何为抽象？
  从抽象去理解抽象是意淫，从具体去理解抽象才是学习

- 爬楼梯

  假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
  每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

  - 递归思想分析问题
    - 定位到问题的终点
    - 站在终点这个视角，思考后退的可能性

    “问题的终点”指的就是走到第 n 阶楼梯这个目标对应的路径数，我们把它记为 f(n)。

    站在第 n 阶楼梯这个视角， 有哪些后退的可能性呢？

    按照题目中的要求，一次只能后退 1 步或者 2 步。因此可以定位到从第 n 阶楼梯只能后退到第 n-1 或者第 n-2 阶。

    我们把抵达第 n-1 阶楼梯对应的路径数记为f(n-1)，把抵达第 n-2 阶楼梯对应的路径数记为 f(n-2)，不难得出以下关系：

    f(n) = f(n-1) + f(n-2)

    树形结构

    ![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/14/172b19208c250e8a~tplv-t2oaga2asx-jj-mark:3326:0:0:0:q75.awebp)

    f(n-1) = f(n-2) + f(n-3)

    f(n-2) = f(n-3) + f(n-4)

    ![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/14/172b19913098a464~tplv-t2oaga2asx-jj-mark:3326:0:0:0:q75.awebp)

    f(1) = 1   
    f(2) = 2

    遇到**“树形思维模型”**，就要想办法往递归上靠。

    有着明确的重复内容(不断地按照 f(n) = f(n-1) + f(n-2)的规则拆分），同时有着明确的边界条件(遇到f(1)或f(2)就可以返回了)，

    1.js


- 问题？
  丢进 OJ 会直接超时
  通常是指在线评测系统（Online Judge），这类系统用于自动评估编程题目的解决方案

  ![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/14/172b199e151d2d3d~tplv-t2oaga2asx-jj-mark:3326:0:0:0:q75.awebp)

  **标红** 重复计算， 且随着递归层级的加深， 重复的问题会越来越严重。

  ![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/28/1739430a97f10d22~tplv-t2oaga2asx-jj-mark:3326:0:0:0:q75.awebp)


- 解决方案 记忆化搜索 

  **用空间换时间**

  const f = []

  2.js

  以上这种在递归的过程中，不断保存已经计算出的结果，从而避免重复计算的手法，叫做记忆化搜索。

- 动态规划

  总结

  先说记忆化搜索，记忆化搜索可以理解为优化过后的递归。递归往往可以基于树形思维模型来做，以这道题为例：

  我们基于树形思维模型来解题时，实际上是站在了一个比较大的未知数量级（也就是最终的那个n），来不断进行拆分，最终拆回较小的已知数量级（f(1)、f(2)）。这个过程是一个明显的自顶向下的过程。

  动态规划则恰恰相反，是一个自底向上的过程。它要求我们站在已知的角度，通过定位已知和未知之间的关系，一步一步向前推导，进而求解出未知的值。
在这道题中，已知 f(1) 和 f(2) 的值，要求解未知的 f(n)，我们唯一的抓手就是这个等价关系：

  - 未知和已知

  - 状态转移方程

- 爬楼梯用动态规划， 两个关键特征
  这道题目有两个关键的特征：
    要求你给出达成某个目的的解法个数
    不要求你给出每一种解法对应的具体路径

- 对比

  树形思维模型将帮助我们更迅速地定位到状态转移关系，边界条件往往对应的就是已知子问题的解；

  基于树形思维模型，结合一下记忆化搜索，难么？不难，谁还不会初始化个记忆数组了呢；最后再把递归往迭代那么一转，答案不就有了么！

  实际上，动态规划可复杂了

  递归+记忆化搜索的思想只是帮助我们简化问题，但并不能送佛送到西。说到底，还是得靠我们自己。
动态规划到底复杂在什么地方，这里我先预告一下：

  - 状态转移方程不好确定
  - 已知的状态可能不明显
  - 递归转迭代，



  递归思想明确树形思维模型：找到问题终点，思考倒退的姿势，往往可以帮助你更快速地明确状态间的关系
结合记忆化搜索，明确状态转移方程
递归代码转化为迭代表达（这一步不一定是必要的，1、2本身为思维路径，而并非代码实现。若你成长为熟手，2中分析出来的状态转移方程可以直接往循环里塞，根本不需要转换）。

- dp 优点
  - 减少重复计算 动态规划通过存储已经计算过的值，避免了递归中的大量重复计算，显著提高了效率
  - 更低的时间复杂度
    从 O(2n) 到 O（n）

    更好的可读性和维护性：虽然递归实现可能看起来更简洁，但动态规划版本通常更容易理解和维护，特别是当问题变得更复杂时。


