[source](https://www.hello-algo.com/chapter_greedy/greedy_algorithm/)

贪心算法是在解决优化问题时，每一步都选择当前看起来最优的方案，期望最终能得到全局最优解。

- 怎么找对象？
  如果女神用贪心算法来找对象，她会在每个阶段都选择当前看起来指标最高的那个，比如第一眼先看谁最有钱，然后在有钱人里找谁最帅，最后发现人品最差。

- 找零问题
  假设你要找给顾客一定数额的零钱，你有不同面值的硬币 (比如 1 元、5 元、10 元、20 元)，目标是用最少的硬币数量找零。
  
  给定 n种硬币，第 i种硬币的面值为 coins[i-1]，目标金额为 ant，每种硬币可以重复选取，问能够凑出目标金额的最少硬币数量。如果无法凑出目标金额，则返回 -1。

  - 如何贪心？
    不大于且最接近目标金额的硬币。不断**循环**该步骤，直至凑出目标金额为止。
  - 解题 1.js
  - So clean ！贪心算法仅用约十行代码就解决了零钱兑换问题。


- 对比动态规划
  递归思想去分析 自顶向下
  - 树状问题 ![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/14/172b1a91f12139e5~tplv-t2oaga2asx-jj-mark:3326:0:0:0:q75.awebp)
  - f(36) = Math.min(f(36-c1)+1,f(36-c2)+1,f(36-c3)+1......f(36-cn)+1)
  - 自下向上 迭代 
  定义状态: dp[i] 表示找零金额为 i 时所需的最少硬币数量。
  状态转移方程: dp[i] = min(dp[i], dp[i-coin]+1)

  2.js

- 贪心 动态规划对比
  贪心算法的思路简洁易懂， 而动态规划的代码实现相对复杂。
  
  在以上代码中，记硬币最小面值为 Math.min(Coins)，则贪心选择最多循环 amt/Math.min(Coins)次，时间复杂度为 O(ant/min(coins))。这比动态规划解法的时间复杂度 O(n*ant)小了一个数量级。

  - 缺点
    [1, 20, 50]  贪心算法只能找到50+1*10 的兑换组合，共计 11枚硬币

    动态规划 20+20+20 3枚

    [1, 49 50]

    对于某些特殊的硬币面值组合， 贪心算法确实可能无法找到最优解。 这并不意味着贪心算法是错误的， 也不代表我们应该完全放弃贪心算法。

    虽然贪心算法不能保证找到全局最优解， 但在很多情况下可以快速得到不错的结果， 并且代码实现简单， 效率高。

    贪心 解决优化问题， 局部最优 不一定全局最优
    动态 解决 所有问题 局部最优 全局最优

    都有最优子结构 

    可以保证找到最优解：贪心算法在这种情况下往往是最优选择，因为它往往比回溯、动态规划更高效。
可以找到近似最优解：贪心算法在这种情况下也是可用的。对于很多复杂问题来说，寻找全局最优解非常困难，能以较高效率找到次优解也是非常不错的