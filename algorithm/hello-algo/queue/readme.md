[source](https://www.hello-algo.com/chapter_stack_and_queue/queue/)

# 队列

- 何为队列？
  Queue 遵循先入先出（FIFO）规则的线性数据结构
- 结合数组 入队， 出队怎么做
  1.js
- 看图， 聊聊队列的ADT
  ![](https://www.hello-algo.com/chapter_stack_and_queue/queue.assets/queue_operations.png)
  - 队列 Queue 模拟排队
  - 队首 出队
  - 队尾 入队
  - push  pop  peek(O(1) 队首)
- es6 实现队列 2.js
  - 基于链表
    2.js 
  - 基于数组
    3.js
    在数组中删除首元素的时间复杂度为 O(n)，这会导致出队操作效率较低？
    这是因为删除首元素后，需要将数组中剩余的 n-1 个元素 全部向前移动一位，以填补空缺。这个操作需要遍历整个数组，因此时间复杂度为 O(n)。
    假设有一个数组 ，要删除首元素 1。
    1.
    删除首元素后，数组变为 [ , 2, 3, 4, 5]。
    2.
    将剩余元素向前移动一位，得到 。
    - 使用数组实现队列时，出队操作的效率较低，时间复杂度为 O(n)。

  - 优缺点比较
    数组的优点
    - 空间局部性好: 数组元素存储在连续的内存空间中，可以更好地利用 CPU 缓存，提高数据访问速度
    - 实现简单: 数组实现队列的代码相对简单，易于理解和维护。
    链表的缺点
    - 空间效率较低: 链表需要额外的空间来存储指针，每个节点都需要存储指向下一个节点的指针，这会增加内存开销。
    - 缓存利用率低: 链表元素分散存储在内存中，空间局部性较差，缓存命中率较低，数据访问速度较慢。  

    假设有一个数组 ，存储在内存地址 1000 到 1019 中。当 CPU 访问元素 1 时，CPU 缓存可能会将 1000 到 1031 的内存数据加载到缓存中。

    因此，数组元素存储在连续的内存空间中，可以更好地利用 CPU 缓存的空间局部性原理，提高缓存命中率，从而提高数据访问速度。

  - 自动扩容 4.js

## 双端队列
  - 为了在队列的两端进行高效的插入和删除操作，需要使用双向队列
  - 出队， O(n) 数组
  - push_first push_last pop_first pop_last  peek_first peek_last

  - 5.js 简单实现