# 从0到1掌握算法面试需要的数据结构 树与二叉树
[https://juejin.cn/book/6844733800300150797/section/6844733800346288142](https://juejin.cn/book/6844733800300150797/section/6844733800346288142)

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/6/1714ec42acc57e04~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp)
这是什么遍历？ 先序遍历



## 理解树结构

- 树有什么特点？
  - 一个树根 root
  - 树枝抽象为“边”
  - 树枝的两个端点抽象为“结点”
  - 树叶抽象为“叶子结点”
  ![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/15/1717d9e07221bb94~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp)
  倒过来
  ![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/6/1714e6b267f22329~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp)

- 关键特性
  - 树的层次计算规则：根结点所在的那一层记为第一层，其子结点所在的就是第二层，以此类推。
  - 结点和树的“高度”计算规则：叶子结点高度记为1，每向上一层高度就加1，逐层向上累加至目标结点时，所得到的的值就是目标结点的高度。树中结点的最大高度，称为“树的高度”。
  - “度”的概念：一个结点开叉出去多少个子树，被记为结点的“度”。
  - “叶子结点”：叶子结点就是度为0的结点。

## 二叉树
- 它可以没有根结点，作为一棵空树存在
- 如果它不是空树，那么必须由根结点、左子树和右子树组成，且左右子树都是二叉树。（递归）

- 二叉树能不能被简单定义为每个结点的度都是2的树？
  不能， 普通的树并不会区分左子树和右子树，但在二叉树中，左右子树的位置是严格约定、不能交换的。

  ![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/6/1714e6b275ab6309~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp)
  - 二叉树允许结点的度小于2 叶子结点的度为0
  - “每个结点度都是2”的树是“满二叉树”的一种特殊情况
    除了叶子结点度为0）
  - 二叉树还强调“左右子树有序”
  对应到图上来看，也就意味着 B 和 C、D 和 E、F 和 G 是不能互换的。

## 二叉树的编码实现
- 在 JS 中，二叉树使用对象来定义
  - 数据域
  - 左侧子结点（左子树根结点）的引用
  - 右侧子结点（右子树根结点）的引用
  ```
  // 二叉树结点的构造函数
  function TreeNode(val) {
      this.val = val;
      this.left = this.right = null;
  }
  const node  = new TreeNode(1)
  ```
  ![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/6/1714e6b26ae0d174~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp)

  ![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/6/1714e6b268b61522~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp)


## 二叉树的遍历
二叉树的各种姿势的遍历，是非常容易作为独立命题点来考察的。
这么熟悉的题目你没必要现场推理，你要做的是默写！默写啊！

- 以一定的顺序规则，逐个访问二叉树的所有结点，这个过程就是二叉树的遍历。
  按根结点的访问顺序不同，遍历方式可分为：
  - 先序遍历
  - 中序遍历
  - 后序遍历
  - 层次遍历
  按照实现方式的不同，遍历方式又可以分为以下两种：
  - 递归遍历（先、中、后序遍历）
  - 迭代遍历（层次遍历）

  二叉树和“递归”两个大热命题点， 又比较基础， 考察热度经久不衰。

## 递归遍历初相见

> 编程语言中，函数Func(Type a,……)直接或间接调用函数本身，则该函数称为递归函数。

当我们看到一个函数反复调用它自己的时候，递归就发生了。“递归”就意味着“反复”，像咱们之前对二叉树的定义，就可以理解为是一个递归式的定义：

- 它可以没有根结点，作为一棵空树存在
- 如果它不是空树，那么必须由根结点、左子树和右子树组成，且左右子树都是二叉树。

这个定义有着这样的内涵：如果我们想要创建一个二叉树结点作为根结点，那么它左侧的子结点和右侧的子结点也都必须符合二叉树结点的定义，这意味着我们要反复地执行“创建一个由数据域、左右子树组成的结点”这个动作，直到数据被分配完为止。

- ![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/6/1714ec42acc57e04~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp)
  用对象表达出来
  ```
  const root = {
  val: "A",
  left: {
    val: "B",
    left: {
      val: "D"
    },
    right: {
      val: "E"
    }
  },
  right: {
    val: "C",
    right: {
      val: "F"
    }
  }
};
  ```

### 递归函数的编写要点
- 递归式
  递归式，它指的是你每一次重复的内容是什么。
  在这里，我们要做先序遍历，那么每一次重复的其实就是 根结点 -> 左子树 -> 右子树 这个旅行路线。
- 递归边界
  你什么时候停下来。
  当我们发现遍历的目标树为空的时候，就意味着旅途已达终点、需要画上句号了。

```
// 所有遍历函数的入参都是树的根结点对象
function preorder(root) {
    // 递归边界，root 为空
    if(!root) {
        return 
    }
     
    // 输出当前遍历的结点值
    console.log('当前遍历的结点值是：', root.val)  
    // 递归遍历左子树 
    preorder(root.left)  
    // 递归遍历右子树  
    preorder(root.right)
}

```