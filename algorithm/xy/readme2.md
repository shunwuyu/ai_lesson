# 栈和队列

- 怎么看待栈和队列？
  - 栈和队列两种运算受限的线性表
    - 栈：先进后出（Last In First Out，LIFO）
    - 队列：先进先出（First In First Out，FIFO）
    增删操作
  - 在 JavaScript 中，栈和队列的实现一般都要依赖于数组，可以把栈和队列都看作是“特别的数组”。
    基于链表来实现栈和队列约等于脱裤子放屁（链表实现起来会比数组麻烦得多，做不到开箱即用

- 灵活增删的数组
  - 数组中增加元素的三种方法
  1.js
  ![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8bb23bc7244f4f93bd2f85a3c65016e8~tplv-k3u1fbpfcp-jj-mark:3780:0:0:0:q75.awebp)

  - 数组中删除元素的三种方法
  shift 方法-删除数组头部的元素
  2.js

## 链表

链表和数组相似，它们都是有序的列表、都是线性结构（有且仅有一个前驱、有且仅有一个后继）。不同点在于，链表中，数据单位的名称叫做“结点”，而结点和结点的分布，在内存中可以是离散的。

这个“离散”是相对于数组的“连续”来说的
连续和离散
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36ee8a2b5e554d1e99125a3ace41f65a~tplv-k3u1fbpfcp-jj-mark:3780:0:0:0:q75.awebp)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87081b9e7fea480bb20225830f141e9b~tplv-k3u1fbpfcp-jj-mark:3780:0:0:0:q75.awebp)

在链表中，每一个结点的结构都包括了两部分的内容：数据域和指针域
JS 中的链表，是以嵌套的对象的形式来实现的：

{
    // 数据域
    val: 1,
    // 指针域，指向下一个结点
    next: {
        val:2,
        next: ...
    }
} 


数据域存储的是当前结点所存储的数据值，而指针域则代表下一个结点（后继结点）的引用

 有了 next 指针来记录后继结点的引用，每一个结点至少都能知道自己后面的同学是哪位了，原本相互独立的结点之间就有了如下的联系：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d0baf800bfb4b5bb81f6fbc83dfdb9c~tplv-k3u1fbpfcp-jj-mark:3780:0:0:0:q75.awebp)

要想访问链表中的任何一个元素，我们都得从起点结点开始，逐个访问 next，一直访问到目标结点为止。为了确保起点结点是可抵达的，我们有时还会设定一个 head 指针来专门指向链表的开始位置：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/981d8c74866d4aefb8b695c9e4ed0e1e~tplv-k3u1fbpfcp-jj-mark:3780:0:0:0:q75.awebp)

- dummy 节点

## 链表结点的创建

链表元素的添加

链表元素的添加和删除操作，本质上都是在围绕 next 指针做文章。

先来说说添加，直接在尾部添加结点相对比较简单，我们改变一个 next 指针就行。这里记值为2的 node 结点为 node2（假设 node2 是现在的尾部结点），值为3的 node 结点为 node3。假如我要把 node3 添加到 node2 所在链表的尾部，直接把 node2 的 next 指针指向 node3 即可：

任意两结点间插入一个新结点这种类型的增加操作，将会是链表基础中的一个关键考点。

如何在两个结点间插入一个结点？

需要变更的是前驱结点和目标结点的 next 指针指向

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/601217fc64d141f0aed48f6558c53998~tplv-k3u1fbpfcp-jj-mark:3780:0:0:0:q75.awebp)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/faf00f911dc04864ae52a6343dacafa2~tplv-k3u1fbpfcp-jj-mark:3780:0:0:0:q75.awebp)

// 如果目标结点本来不存在，那么记得手动创建
const node3 = new ListNode(3)     
// 把node3的 next 指针指向 node2（即 node1.next）
node3.next = node1.next
// 把node1的 next 指针指向 node3
node1.next = node3


- 链表元素的删除
  ![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc6a1f482c0c4b24bf791171c43167d9~tplv-k3u1fbpfcp-jj-mark:3780:0:0:0:q75.awebp)
  node1.next = node3.next 


在涉及链表删除操作的题目中，重点不是定位目标结点，而是定位目标结点的前驱结点。


## 链表和数组的辨析

数组都对应着一段连续的内存。如果我们想要在任意位置删除一个元素，那么该位置往后的所有元素，都需要往前挪一个位置；相应地，如果要在任意位置新增一个元素，那么该位置往后的所有元素也都要往后挪一个位置。
我们假设数组的长度是 n，那么因增加/删除操作导致需要移动的元素数量，就会随着数组长度 n 的增大而增大，呈一个线性关系。所以说数组增加/删除操作对应的复杂度就是 O(n)。

const arr = [1,2,3,4]

它是一个纯数字数组，那么对应的确实是连续内存。

但如果我们定义了不同类型的元素：

const arr = ['haha', 1, {a:1}]

它对应的就是一段非连续的内存。此时，JS 数组不再具有数组的特征，其底层使用哈希映射分配内存空间，是由对象链表来实现的。

大家谨记“JS 数组未必是真正的数组”即可

链表有一个明显的优点，就是添加和删除元素都不需要挪动多余的元素。

高效的增删操作

在链表中，添加和删除操作的复杂度是固定的——不管链表里面的结点个数 n 有多大，只要我们明确了要插入/删除的目标位置，那么我们需要做的都仅仅是改变目标结点及其前驱/后继结点的指针指向。 因此我们说链表增删操作的复杂度是常数级别的复杂度，用大 O 表示法表示为 O(1)。


麻烦的访问操作

但是链表也有一个弊端：当我们试图读取某一个特定的链表结点时，必须遍历整个链表来查找它。比如说我要在一个长度为 n（n>10） 的链表里，定位它的第 10 个结点，我需要这样做：

const index = 10  
// 设一个游标指向链表第一个结点，从第一个结点开始遍历
let node = head  
// 反复遍历到第10个结点为止
for(let i=0;i<index&&node;i++) {
    node = node.next
}

随着链表长度的增加，我们搜索的范围也会变大、遍历其中任意元素的时间成本自然随之提高。这个变化的趋势呈线性规律，用大 O 表示法表示为 O(n)。

但在数组中，我们直接访问索引、可以做到一步到位，这个操作的复杂度会被降级为常数级别(O(1))：

arr[9]